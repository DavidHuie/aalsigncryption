package aal

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"crypto/subtle"
	"fmt"
	"hash"
	"io"
	"math/big"

	"github.com/DavidHuie/signcryption"
)

// AAL represents all of the different functions possible with the AAL
// signcryption scheme.
type AAL interface {
	Signcrypt(sender *signcryption.PrivateKey, recipient *signcryption.PublicKey, plaintext, additionalData []byte) (*SigncryptionOutput, error)
	Verify(sender, recipient *signcryption.PublicKey, additionalData []byte, output *SigncryptionOutput) (bool, error)
	Unsigncrypt(sender *signcryption.PublicKey, recipient *signcryption.PrivateKey, additionalData []byte, output *SigncryptionOutput) ([]byte, bool, error)
}

type cipherCreator func([]byte) (cipher.Block, error)

type hashCreator func() hash.Hash

type signcrypter struct {
	securityLevel int
	curve         elliptic.Curve
	hashCreator   hashCreator
	cipherCreator cipherCreator
	rand          io.Reader
}

// SigncryptionOutput is the output generated by the signcryption
// process. All of it must be maintained in order to verify and
// unsigncrypt the data.
type SigncryptionOutput struct {
	R          []byte
	Ciphertext []byte
	Signature  []byte
}

func (s *signcrypter) Signcrypt(sender *signcryption.PrivateKey, recipient *signcryption.PublicKey, plaintext, additionalData []byte) (*SigncryptionOutput, error) {
	if err := sender.PublicKey.Validate(); err != nil {
		return nil, fmt.Errorf("error invalid public key: %s", err)
	}
	if err := recipient.Validate(); err != nil {
		return nil, fmt.Errorf("error invalid public key: %s", err)
	}

	prime := s.curve.Params().P
	nMod := s.curve.Params().N

	// choose random v
	vBytes := make([]byte, s.curve.Params().BitSize/8)
	if _, err := io.ReadFull(s.rand, vBytes); err != nil {
		return nil, fmt.Errorf("error reading from rand reader: %s", err)
	}
	v := new(big.Int).SetBytes(vBytes)
	v.Mod(v, new(big.Int).Sub(prime, big.NewInt(1)))

	// compute r
	// TODO: a 33 byte compressed version of R might make sense here.
	xR, yR := s.curve.ScalarBaseMult(v.Bytes())
	rMarshaled := elliptic.Marshal(s.curve, xR, yR)

	// compute point p
	p := new(big.Int).Add(v, sender.V)
	p.Mod(p, nMod)

	// compute Q
	xQ, yQ := s.curve.ScalarMult(recipient.X, recipient.Y, p.Bytes())

	// compute session key
	hash := s.hashCreator()
	hash.Write(xQ.Bytes())
	hash.Write(sender.ID)
	hash.Write(yQ.Bytes())
	hash.Write(recipient.ID)
	key := hash.Sum(nil)
	key = key[:s.securityLevel/8]

	// encrypt
	block, err := s.cipherCreator(key)
	if err != nil {
		return nil, fmt.Errorf("error creating AES cipher: %s", err)
	}
	ciphertext := make([]byte, len(plaintext))
	iv := make([]byte, block.BlockSize())
	if _, err := io.ReadFull(s.rand, iv); err != nil {
		return nil, fmt.Errorf("error reading random IV: %s", err)
	}
	ctr := cipher.NewCTR(block, iv)
	ctr.XORKeyStream(ciphertext, plaintext)
	ciphertext = append(iv, ciphertext...)

	// create tag
	hash = s.hashCreator()
	hash.Write(additionalData)
	hash.Write(iv)
	hash.Write(ciphertext)
	hash.Write(xR.Bytes())
	hash.Write(sender.ID)
	hash.Write(yR.Bytes())
	hash.Write(recipient.ID)
	t := new(big.Int).SetBytes(hash.Sum(nil))

	// create signature
	sig := new(big.Int).ModInverse(t, prime)
	sig.Mul(sig, p)
	sig.Mod(sig, prime)

	return &SigncryptionOutput{
		R:          rMarshaled,
		Ciphertext: ciphertext,
		Signature:  sig.Bytes(),
	}, nil
}

func (s *signcrypter) Verify(sender, recipient *signcryption.PublicKey, additionalData []byte, output *SigncryptionOutput) (bool, error) {
	if err := sender.Validate(); err != nil {
		return false, fmt.Errorf("error invalid public key: %s", err)
	}
	if err := recipient.Validate(); err != nil {
		return false, fmt.Errorf("error invalid public key: %s", err)
	}

	// parse r
	xR, yR := elliptic.Unmarshal(s.curve, output.R)

	// extract IV
	iv := output.Ciphertext[:aes.BlockSize]
	ciphertext := output.Ciphertext[aes.BlockSize:]

	// compute tag
	hash := s.hashCreator()
	hash.Write(additionalData)
	hash.Write(iv)
	hash.Write(ciphertext)
	hash.Write(xR.Bytes())
	hash.Write(sender.ID)
	hash.Write(yR.Bytes())
	hash.Write(recipient.ID)
	t := hash.Sum(nil)

	// compute verification equation #1
	mX, mY := s.curve.ScalarBaseMult(output.Signature)
	vX1, vY1 := s.curve.ScalarMult(mX, mY, t)

	// compute verification equation #2
	vX2, vY2 := s.curve.Add(xR, yR, sender.X, sender.Y)

	xEqual := subtle.ConstantTimeCompare(vX1.Bytes(), vX2.Bytes())
	yEqual := subtle.ConstantTimeCompare(vY1.Bytes(), vY2.Bytes())

	return (xEqual == 0) && (yEqual == 0), nil
}

type vmsg struct {
	valid bool
	err   error
}

func (s *signcrypter) Unsigncrypt(sender *signcryption.PublicKey, recipient *signcryption.PrivateKey, additionalData []byte, output *SigncryptionOutput) ([]byte, bool, error) {
	if err := sender.Validate(); err != nil {
		return nil, false, fmt.Errorf("error invalid public key: %s", err)
	}
	if err := recipient.PublicKey.Validate(); err != nil {
		return nil, false, fmt.Errorf("error invalid public key: %s", err)
	}

	// verify the signature in parallel
	vchan := make(chan *vmsg)
	go func() {
		valid, verr := s.Verify(sender, &recipient.PublicKey, additionalData, output)
		vchan <- &vmsg{valid, verr}
	}()

	// parse r
	xR, yR := elliptic.Unmarshal(s.curve, output.R)

	// compute p & q
	xP, yP := s.curve.Add(xR, yR, sender.X, sender.Y)
	xQ, yQ := s.curve.ScalarMult(xP, yP, recipient.V.Bytes())

	// compute session key
	hash := s.hashCreator()
	hash.Write(xQ.Bytes())
	hash.Write(sender.ID)
	hash.Write(yQ.Bytes())
	hash.Write(recipient.ID)
	key := hash.Sum(nil)
	key = key[:s.securityLevel/8]

	// extract IV
	iv := output.Ciphertext[:aes.BlockSize]
	ciphertext := output.Ciphertext[aes.BlockSize:]

	// recover plaintext
	plaintext := make([]byte, len(ciphertext))
	block, err := s.cipherCreator(key)
	if err != nil {
		return nil, false, fmt.Errorf("error creating AES cipher: %s", err)
	}

	ctr := cipher.NewCTR(block, iv)
	ctr.XORKeyStream(plaintext, ciphertext)

	// Check the results for the parallel signature verification.
	msg := <-vchan
	if msg.err != nil {
		return nil, false, fmt.Errorf("error validating signature: %s", err)
	}
	if !msg.valid {
		return nil, false, nil
	}

	return plaintext, true, nil
}

// NewP256 returns an AAL instance based on the elliptic curve
// P256. The instance uses AES-CTR-128 for encrypting and SHA-256 for
// generating keys. This signcryption scheme provides security at the
// 128-bit level.
func NewP256() AAL {
	return newP256(rand.Reader)
}

func newP256(rand io.Reader) AAL {
	return &signcrypter{
		securityLevel: 128,
		curve:         elliptic.P256(),
		hashCreator:   sha256.New,
		cipherCreator: aes.NewCipher,
		rand:          rand,
	}
}

// NewP521 returns an AAL instance based on the elliptic curve
// P521. The signcrypter uses AES-CTR-512 for encrypting and SHA-512
// for generating keys. This signcryption scheme provides security at
// the 256-bit level.
func NewP521() AAL {
	return newP521(rand.Reader)
}

func newP521(rand io.Reader) AAL {
	return &signcrypter{
		securityLevel: 256,
		curve:         elliptic.P521(),
		hashCreator:   sha256.New,
		cipherCreator: aes.NewCipher,
		rand:          rand,
	}
}
